<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Drag & Drop interne</title>
  <style>
    #container {
      width: 400px;
      padding: 10px;
      border: 2px dashed #ccc;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      transition: all 0.3s ease;
    }
    .item, .placeholder {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: transform 0.2s ease, background-color 0.2s ease;
    }
    .item {
      background-color: lightblue;
      cursor: move;
      animation: rubberBand 0.5s ease-in-out;
    }
    .item.dragging {
       display: none; 
    } 
    .placeholder {
      border: 2px dashed #aaa;
      background-color: transparent;
    }
    @keyframes rubberBand {
       0% {
        transform: scale(0.7,  );
      }
      40% {
        transform: scale(.8 );
      }
      50% {
        transform: scale(1.3);
      }
      65% {
        transform: scale(.95 );
      }
      75% {
        transform: scale( 1.09  );
      }
      100% {
        transform: scale(1);
      }
    }
  </style>
</head>
<body>

<h2>Déplace les éléments</h2>
<div id="container">
  <div class="item" draggable="true">1</div>
  <div class="item" draggable="true">2</div>
  <div class="item" draggable="true">3</div>
  <div class="item" draggable="true">4</div>
</div>

<script>
const container = document.getElementById('container');
let draggedItem = null;
let placeholder = document.createElement('div');
placeholder.className = 'placeholder';

container.addEventListener('dragstart', (e) => {
  if (e.target.classList.contains('item')) {
    draggedItem = e.target;
    e.target.classList.add('dragging');
    setTimeout(() => {
      e.target.style.width = 'none';
    }, 0);
  }
});

container.addEventListener('dragend', (e) => {
  if (e.target.classList.contains('item')) {
    e.target.classList.remove('dragging');
    setTimeout(() => {
      e.target.style.display = 'flex';
      draggedItem = null;
      if (placeholder.parentNode) {
        placeholder.parentNode.removeChild(placeholder);
      }
    }, 0);
  }
});

container.addEventListener('dragover', (e) => {
  e.preventDefault();
  const afterElement = getDragAfterElement(container, e.clientX);
  if (afterElement == null) {
    container.appendChild(placeholder);
  } else {
    container.insertBefore(placeholder, afterElement);
  }
});

container.addEventListener('drop', (e) => {
  e.preventDefault();
  if (placeholder.parentNode) {
    container.insertBefore(draggedItem, placeholder);
    placeholder.parentNode.removeChild(placeholder);
  }
});

// Trouver l'élément après lequel on doit insérer
function getDragAfterElement(container, x) {
  const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')];

  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = x - box.left - box.width / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}
</script>

</body>
</html>
